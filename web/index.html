<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport"
    content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-fullscreen">
  <meta name="screen-orientation" content="landscape">
  <title>‚üÅ PulseQuest</title>
  <style>
    :root {
      --bg: #0a0e27;
      --card: #1a1f3a;
      --text: #e0e7ff;
      --stroke: #2d3561;
      --accent: #8b5cf6;
      --beacon: #fbbf24;
      --empty: #0f1729;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: linear-gradient(135deg, 
        #0a0e27 0%,
        #1a1b4b 25%,
        #2d1b4e 50%,
        #1a1b4b 75%,
        #0a0e27 100%
      );
      background-size: 400% 400%;
      animation: nebula-flow 20s ease infinite;
      color: var(--text);
      overflow: hidden;
      width: 100vw;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
    }

    @keyframes nebula-flow {
      0%, 100% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
    }

    body::before {
      content: '';
      position: fixed;
      inset: 0;
      background-image: 
        radial-gradient(2px 2px at 20% 30%, white, transparent),
        radial-gradient(2px 2px at 60% 70%, white, transparent),
        radial-gradient(1px 1px at 50% 50%, white, transparent),
        radial-gradient(1px 1px at 80% 10%, white, transparent),
        radial-gradient(2px 2px at 90% 60%, white, transparent),
        radial-gradient(1px 1px at 33% 80%, white, transparent),
        radial-gradient(1px 1px at 15% 90%, white, transparent);
      background-size: 200% 200%;
      animation: stars-twinkle 3s ease-in-out infinite;
      pointer-events: none;
      opacity: 0.6;
      z-index: 1;
    }

    @keyframes stars-twinkle {
      0%, 100% { opacity: 0.6; }
      50% { opacity: 0.9; }
    }

    .shell {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      padding: 10px;
      position: relative;
      z-index: 2;
    }

    .card {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: var(--card);
      border: 1px solid var(--stroke);
      border-radius: 12px;
      overflow: hidden;
      position: relative;
      width: 100%;
      height: 100%;
      min-height: 0;
    }

    .hud {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 20px;
      border-bottom: 1px solid var(--stroke);
      background: rgba(0, 0, 0, 0.3);
      gap: 20px;
      flex-wrap: wrap;
    }

    .hud-left {
      display: flex;
      align-items: center;
      gap: 16px;
    }

    .hud-center {
      display: flex;
      align-items: center;
      gap: 20px;
    }

    .title {
      font-size: clamp(16px, 4vw, 20px);
      font-weight: 800;
      color: var(--beacon);
      text-shadow: 0 0 10px rgba(251, 191, 36, 0.5);
    }

    .info {
      font-size: clamp(12px, 3vw, 14px);
      color: var(--text);
    }

    .stage {
      flex: 1;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: relative;
      touch-action: none;
      min-height: 0;
      overflow: hidden;
    }

    #grid {
      width: 100%;
      height: auto;
      max-height: 100%;
      aspect-ratio: 14 / 4;
      display: grid;
      grid-template-columns: repeat(14, 1fr);
      grid-template-rows: repeat(4, 1fr);
      gap: clamp(2px, 0.5vw, 6px);
      padding: clamp(4px, 0.8vw, 8px);
      background: rgba(10, 14, 39, 0.8);
      backdrop-filter: blur(10px);
      border: 2px solid var(--stroke);
      border-radius: 8px;
      box-shadow: 0 0 30px rgba(139, 92, 246, 0.3);
      min-height: 0;
    }

    .cell {
      width: 100%;
      height: 100%;
      aspect-ratio: 1;
      border-radius: clamp(2px, 0.3vw, 4px);
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      background: linear-gradient(135deg, #0f1729 0%, #1a1f3a 100%);
      border: 1px solid rgba(139, 92, 246, 0.2);
    }

    /* Responsive adjustments */
    /* Small phones (<375px) */
    @media (max-width: 374px) {
      .shell {
        padding: 4px;
      }

      .hud {
        padding: 8px 10px;
        gap: 10px;
      }

      .hud-center {
        gap: 10px;
      }

      .stage {
        padding: 8px;
      }

      .controls-panel {
        padding: 8px 10px;
      }

      .menu-btn {
        padding: 6px 10px;
        font-size: 14px;
      }
    }

    /* Phones (375px-768px) */
    @media (max-width: 768px) {
      .shell {
        padding: 6px;
      }

      .hud {
        padding: 10px 12px;
      }

      .stage {
        padding: 12px;
      }

      .controls-panel {
        padding: 10px 12px;
      }
    }

    /* Tablets (768px-1024px) */
    @media (min-width: 768px) and (max-width: 1023px) {
      .stage {
        padding: 16px;
      }
    }

    /* Desktop (1024px-1440px) */
    @media (min-width: 1024px) {
      .stage {
        padding: 20px;
      }
    }

    /* Large desktop (>1440px) - prevent over-scaling */
    @media (min-width: 1440px) {
      .stage {
        padding: 24px;
      }

      #grid {
        max-width: 1200px;
      }
    }

    .cell.beacon {
      background: linear-gradient(135deg, #92400e 0%, #78350f 100%);
      border-color: rgba(251, 191, 36, 0.5);
      box-shadow: 0 0 20px rgba(251, 191, 36, 0.4);
    }

    .cell.wall {
      background: linear-gradient(135deg, #3f3f46 0%, #27272a 100%);
      border-color: rgba(161, 161, 170, 0.3);
    }

    .player {
      font-size: clamp(14px, 3vw, 22px);
      filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.5));
    }

    .icon {
      font-size: clamp(14px, 3vw, 22px);
    }

    /* Compass - in HUD header */
    .compass {
      width: clamp(48px, 12vw, 60px);
      height: clamp(48px, 12vw, 60px);
      background: rgba(10, 14, 39, 0.9);
      border: 2px solid rgba(139, 92, 246, 0.5);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 0 20px rgba(139, 92, 246, 0.3);
    }

    .compass-inner {
      position: relative;
      width: 75%;
      height: 75%;
    }

    .compass-arrow {
      position: absolute;
      font-size: clamp(10px, 2.5vw, 12px);
      opacity: 0.3;
      transition: opacity 0.3s, transform 0.3s;
    }

    .compass-arrow.active {
      opacity: 1;
      color: #ffd166;
      transform: scale(1.3);
      filter: drop-shadow(0 0 8px #ffd166);
    }

    .compass-arrow.n {
      top: 0;
      left: 50%;
      transform: translateX(-50%);
    }

    .compass-arrow.n.active {
      transform: translateX(-50%) scale(1.3);
    }

    .compass-arrow.e {
      top: 50%;
      right: 0;
      transform: translateY(-50%);
    }

    .compass-arrow.e.active {
      transform: translateY(-50%) scale(1.3);
    }

    .compass-arrow.s {
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
    }

    .compass-arrow.s.active {
      transform: translateX(-50%) scale(1.3);
    }

    .compass-arrow.w {
      top: 50%;
      left: 0;
      transform: translateY(-50%);
    }

    .compass-arrow.w.active {
      transform: translateY(-50%) scale(1.3);
    }

    /* Settings Drawer */
    .drawer {
      position: absolute;
      top: 0;
      right: 0;
      bottom: 0;
      width: min(280px, 80vw);
      background: rgba(10, 15, 30, 0.98);
      border-left: 1px solid var(--stroke);
      z-index: 1000;
      transform: translateX(100%);
      transition: transform 0.4s cubic-bezier(0.16, 1, 0.3, 1);
      display: flex;
      flex-direction: column;
      backdrop-filter: blur(24px);
      box-shadow: -20px 0 50px rgba(0, 0, 0, 0.8);
    }

    .drawer.open {
      transform: translateX(0);
    }

    .drawer-header {
      padding: 24px 20px 10px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .drawer h3 {
      font-size: 20px;
      color: var(--beacon);
      font-weight: 800;
      margin: 0;
    }

    .close-btn {
      background: rgba(255, 255, 255, 0.05);
      border: none;
      color: #fff;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      font-size: 24px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .settings {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 14px;
      padding: 20px;
      overflow-y: auto;
    }

    .settings label,
    .settings select {
      width: 100%;
      text-align: left;
      font-size: 14px;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.03));
      padding: 16px;
      border-radius: 12px;
      border: 1px solid var(--stroke);
      color: var(--text);
      cursor: pointer;
      transition: all 0.2s;
      font-weight: 500;
    }

    .settings select:hover {
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.12), rgba(255, 255, 255, 0.06));
      border-color: var(--accent);
      transform: translateY(-1px);
    }

    .settings select:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(108, 168, 255, 0.1);
    }

    .settings select option {
      background: #0f1420;
      color: var(--text);
      padding: 10px;
    }

    .menu-btn {
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.03));
      border: 1px solid var(--stroke);
      color: var(--text);
      padding: clamp(6px, 2vw, 8px) clamp(10px, 3vw, 12px);
      border-radius: 8px;
      cursor: pointer;
      font-size: clamp(14px, 3.5vw, 16px);
      font-weight: 600;
      transition: all 0.2s;
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .menu-btn:hover {
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.12), rgba(255, 255, 255, 0.06));
      border-color: var(--accent);
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }

    .menu-btn:active {
      transform: translateY(0);
    }

    /* Sonar Blinkers */
    .sonar-blinkers {
      display: flex;
      gap: clamp(12px, 3vw, 16px);
      padding: clamp(8px, 2vw, 10px) clamp(16px, 4vw, 20px);
      background: rgba(10, 14, 39, 0.9);
      border-radius: 99px;
      border: 2px solid rgba(139, 92, 246, 0.5);
    }

    .sonar-led {
      width: clamp(20px, 5vw, 24px);
      height: clamp(20px, 5vw, 24px);
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.15);
      border: 2px solid rgba(255, 255, 255, 0.3);
      transition: all 0.15s;
      position: relative;
    }

    .sonar-led::before {
      content: '';
      position: absolute;
      inset: -6px;
      border-radius: 50%;
      background: radial-gradient(circle, var(--accent) 0%, transparent 70%);
      opacity: 0;
      transition: opacity 0.15s;
    }

    .sonar-led.active {
      background: var(--accent);
      border-color: var(--accent);
      box-shadow: 0 0 24px var(--accent), inset 0 0 12px rgba(255, 255, 255, 0.5);
    }

    .sonar-led.active::before {
      opacity: 0.7;
    }

    .sonar-led.long {
      background: var(--beacon);
      border-color: var(--beacon);
      box-shadow: 0 0 24px var(--beacon), inset 0 0 12px rgba(255, 255, 255, 0.5);
    }

    /* Controls Panel */
    .controls-panel {
      background: rgba(0, 0, 0, 0.4);
      border-top: 1px solid var(--stroke);
      padding: clamp(10px, 3vw, 16px) clamp(12px, 4vw, 20px);
      display: flex;
      justify-content: center;
      gap: clamp(12px, 4vw, 40px);
      flex-wrap: wrap;
    }

    .control-item {
      display: flex;
      align-items: center;
      gap: clamp(6px, 2vw, 8px);
      font-size: clamp(11px, 2.5vw, 13px);
      color: rgba(255, 255, 255, 0.8);
    }

    .control-key {
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid var(--stroke);
      border-radius: 4px;
      padding: clamp(3px, 1vw, 4px) clamp(6px, 2vw, 8px);
      font-weight: 600;
      font-size: clamp(10px, 2.5vw, 12px);
      color: var(--accent);
      min-width: clamp(50px, 12vw, 60px);
      text-align: center;
    }

    #overlay {
      position: absolute;
      inset: 0;
      background: rgba(7, 10, 22, 0.95);
      backdrop-filter: blur(20px);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
      cursor: pointer;
    }

    #overlay.hidden {
      display: none;
    }

    #overlay h2 {
      font-size: clamp(32px, 10vw, 48px);
      margin-bottom: 10px;
      color: var(--beacon);
    }

    #overlay p {
      font-size: clamp(12px, 3vw, 14px);
      color: var(--accent);
    }

    #win {
      position: absolute;
      inset: 0;
      background: rgba(7, 10, 22, 0.95);
      backdrop-filter: blur(20px);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
      padding: 20px;
    }

    #win.hidden {
      display: none;
    }

    #win h2 {
      font-size: clamp(48px, 12vw, 64px);
      margin-bottom: 20px;
    }

    #win p {
      font-size: clamp(14px, 3.5vw, 18px);
      text-align: center;
    }
  </style>
</head>

<body>
  <div class="shell">
    <div class="card">
      <div class="hud">
        <div class="hud-left">
          <div class="title">‚üÅ PulseQuest</div>
        </div>
        <div class="hud-center">
          <div class="compass">
            <div class="compass-inner">
              <div class="compass-arrow n" id="compass-n">‚ñ≤</div>
              <div class="compass-arrow e" id="compass-e">‚ñ∫</div>
              <div class="compass-arrow s" id="compass-s">‚ñº</div>
              <div class="compass-arrow w" id="compass-w">‚óÄ</div>
            </div>
          </div>
          <div class="sonar-blinkers">
            <div class="sonar-led" id="led-left"></div>
            <div class="sonar-led" id="led-right"></div>
          </div>
        </div>
        <div class="info">
          Pos: <span id="pos">1,1</span> | Dir: <span id="dir">E</span> | Steps: <span id="steps">0</span>
          <button class="menu-btn" onclick="toggleDrawer()" style="margin-left: 15px;">üó∫Ô∏è</button>
        </div>
      </div>

      <div class="stage" id="stage">
        <div id="grid"></div>
      </div>

      <div class="controls-panel">
        <div class="control-item">
          <span class="control-key">Tap Left</span>
          <span>Move Forward</span>
        </div>
        <div class="control-item">
          <span class="control-key">Tap Right</span>
          <span>Turn Right 90¬∞</span>
        </div>
        <div class="control-item">
          <span class="control-key">Hold Both</span>
          <span>Sonar Scan</span>
        </div>
        <div class="control-item">
          <span class="control-key">W / ‚Üë</span>
          <span>Move (Desktop)</span>
        </div>
        <div class="control-item">
          <span class="control-key">D / ‚Üí</span>
          <span>Turn (Desktop)</span>
        </div>
      </div>

      <!-- Settings Drawer -->
      <div id="drawer" class="drawer">
        <div class="drawer-header">
          <h3>Settings</h3>
          <button class="close-btn" onclick="toggleDrawer()">√ó</button>
        </div>
        <div class="settings">
          <select id="mapSelect" onchange="loadMap()">
            <option value="0">Map: Empty</option>
            <option value="1">Map: Simple Maze</option>
            <option value="2">Map: Challenge</option>
          </select>
        </div>
      </div>
    </div>
  </div>

  <div id="overlay">
    <h2>‚üÅ PulseQuest</h2>
    <p>Tap to begin</p>
  </div>

  <div id="win" class="hidden">
    <h2>ü•á</h2>
    <p>Treat found! You have saved the world!!</p>
    <div style="margin-top: 20px;">
      <select id="winMapSelect" onchange="loadMapFromWin()"
        style="padding: 10px 20px; font-size: 14px; border-radius: 8px; background: rgba(255,255,255,0.1); border: 1px solid var(--stroke); color: var(--text); cursor: pointer;">
        <option value="0">Map: Empty</option>
        <option value="1">Map: Simple Maze</option>
        <option value="2">Map: Challenge</option>
      </select>
    </div>
  </div>

  <script>
    // Game constants
    const WIDTH = 14;
    const HEIGHT = 4;
    const DIR = ['N', 'E', 'S', 'W'];
    const DX = [0, 1, 0, -1];
    const DY = [-1, 0, 1, 0];
    const COMPASS_IDS = ['compass-n', 'compass-e', 'compass-s', 'compass-w'];

    // Maps: E = Empty, W = Wall, B = Beacon (14x4 grid)
    const MAPS = [
      // Map 0: Empty
      "EEEEEEEEEEEEEE,EEEEEEEEEEEEEE,EEEEEEEEEEBEEE,EEEEEEEEEEEEEE",
      // Map 1: Simple Maze
      "WWWWWWWWWWWWWW,WEEEEWWWEEEEEW,WEWWWWWWEWWWEW,WEEEEEEEEWWBEW",
      // Map 2: Challenge
      "WWWWWWWWWWWWWW,WEEEEWEEEEEEEW,WEWWWWWWEWWBEW,WEEEEEEEEEEEEW"
    ];

    // Game state
    let map = [];
    let px = 1, py = 1, pd = 1;
    let steps = 0;
    let started = false;
    let beaconX = 19, beaconY = 5;

    // Parse map string
    function parseMap(str) {
      return str.split(',').map(row => row.split(''));
    }

    // Get tile at position
    function getTile(x, y) {
      return (y >= 0 && y < HEIGHT && x >= 0 && x < WIDTH) ? map[y][x] : 'W';
    }

    // Render grid
    function render() {
      const grid = document.getElementById('grid');
      grid.innerHTML = '';

      for (let y = 0; y < HEIGHT; y++) {
        for (let x = 0; x < WIDTH; x++) {
          const cell = document.createElement('div');
          const tile = map[y][x];
          cell.className = 'cell';

          // Beacon
          if (tile === 'B') {
            cell.classList.add('beacon');
            cell.innerHTML = '<span class="icon">ü¶¥</span>';
          }
          // Wall
          else if (tile === 'W') {
            cell.classList.add('wall');
            cell.innerHTML = '<span class="icon">‚òÑÔ∏è</span>';
          }

          // Player
          if (x === px && y === py) {
            cell.innerHTML = '<span class="player">üêï</span>';
          }

          grid.appendChild(cell);
        }
      }

      // Update compass
      COMPASS_IDS.forEach((id, idx) => {
        const arrow = document.getElementById(id);
        if (arrow) {
          arrow.classList.toggle('active', idx === pd);
        }
      });

      // Update HUD
      document.getElementById('pos').textContent = `${px},${py}`;
      document.getElementById('dir').textContent = DIR[pd];
      document.getElementById('steps').textContent = steps;
    }

    // Move forward
    function moveForward() {
      if (!started) return;

      const newX = px + DX[pd];
      const newY = py + DY[pd];

      // Check bounds
      if (newX < 0 || newX >= WIDTH || newY < 0 || newY >= HEIGHT) return;

      // Check for wall
      const tile = getTile(newX, newY);
      if (tile === 'W') return;

      // Move player
      px = newX;
      py = newY;
      steps++;

      // Check win
      if (tile === 'B') {
        document.getElementById('win').classList.remove('hidden');
      }

      render();
    }

    // Turn right
    function turnRight() {
      if (!started) return;
      pd = (pd + 1) % 4;
      render();
    }

    // Distance scan with sonar blinkers
    function performScan() {
      if (!started) return;

      const dx = beaconX - px;
      const dy = beaconY - py;

      // Calculate angle relative to player's facing direction
      const beaconAngle = Math.atan2(dy, dx) * 180 / Math.PI;
      const playerAngle = [0, 90, 180, -90][pd]; // N=0¬∞, E=90¬∞, S=180¬∞, W=-90¬∞
      let relativeAngle = beaconAngle - playerAngle;

      // Normalize to -180 to 180
      while (relativeAngle > 180) relativeAngle -= 360;
      while (relativeAngle < -180) relativeAngle += 360;

      // Determine direction
      let direction;
      if (Math.abs(relativeAngle) <= 25) {
        direction = 'ahead';
      } else if (Math.abs(relativeAngle) >= 155) {
        direction = 'behind';
      } else if (relativeAngle > 0) {
        direction = 'right';
      } else {
        direction = 'left';
      }

      // Calculate Manhattan distance
      const manhattanDist = Math.abs(dx) + Math.abs(dy);

      // Determine blink count (for 21x7 grid)
      let blinkCount;
      if (manhattanDist <= 1) blinkCount = 5;
      else if (manhattanDist <= 3) blinkCount = 4;
      else if (manhattanDist <= 6) blinkCount = 3;
      else if (manhattanDist <= 10) blinkCount = 2;
      else blinkCount = 1;

      // Perform sonar animation
      performSonarBlinks(direction, blinkCount);
    }

    // Sonar blink animation (2 LEDs)
    function performSonarBlinks(direction, distanceBlinks) {
      const leftLed = document.getElementById('led-left');
      const rightLed = document.getElementById('led-right');

      let timeline = [];

      // Direction cue (slower timing: 150ms ON, 200ms gap, 400ms pause before distance)
      if (direction === 'left') {
        timeline.push({ leds: [leftLed], duration: 150, gap: 400 });
      } else if (direction === 'right') {
        timeline.push({ leds: [rightLed], duration: 150, gap: 400 });
      } else if (direction === 'ahead') {
        // Both LEDs short pulse
        timeline.push({ leds: [leftLed, rightLed], duration: 150, gap: 400 });
      } else if (direction === 'behind') {
        // Both LEDs - two long pulses
        timeline.push({ leds: [leftLed, rightLed], duration: 300, gap: 150, long: true });
        timeline.push({ leds: [leftLed, rightLed], duration: 300, gap: 400, long: true });
      }

      // Distance blinks (on both LEDs for clarity)
      for (let i = 0; i < distanceBlinks; i++) {
        const isLast = i === distanceBlinks - 1;
        timeline.push({ leds: [leftLed, rightLed], duration: 150, gap: isLast ? 0 : 200 });
      }

      // Execute timeline
      let currentTime = 0;
      timeline.forEach(step => {
        setTimeout(() => {
          step.leds.forEach(led => {
            led.classList.add('active');
            if (step.long) led.classList.add('long');
          });
          setTimeout(() => {
            step.leds.forEach(led => {
              led.classList.remove('active');
              if (step.long) led.classList.remove('long');
            });
          }, step.duration);
        }, currentTime);
        currentTime += step.duration + step.gap;
      });
    }

    // Load map
    function loadMap() {
      const mapIdx = parseInt(document.getElementById('mapSelect').value);
      map = parseMap(MAPS[mapIdx]);

      // Find beacon position
      for (let y = 0; y < HEIGHT; y++) {
        for (let x = 0; x < WIDTH; x++) {
          if (map[y][x] === 'B') {
            beaconX = x;
            beaconY = y;
          }
        }
      }

      // Reset player position
      px = 1;
      py = 1;
      pd = 1;
      steps = 0;
      document.getElementById('win').classList.add('hidden');
      render();
    }

    // Load map from win screen
    function loadMapFromWin() {
      const mapIndex = parseInt(document.getElementById('winMapSelect').value);
      document.getElementById('mapSelect').value = mapIndex;
      loadMap();
    }

    // Toggle drawer
    function toggleDrawer() {
      document.getElementById('drawer').classList.toggle('open');
    }

    // Touch controls with scan support
    let touchTimeout = null;
    let wasHeld = false;
    const stageEl = document.getElementById('stage');
    const activePointers = new Map();
    let leftTouch = false, rightTouch = false;

    function showFlash(x, y) {
      const flash = document.createElement('div');
      flash.className = 'input-flash';
      flash.style.left = x + 'px';
      flash.style.top = y + 'px';
      document.body.appendChild(flash);
      setTimeout(() => flash.remove(), 400);
    }

    function updateTouchZones() {
      const rect = stageEl.getBoundingClientRect();
      const mid = rect.left + rect.width / 2;

      leftTouch = false;
      rightTouch = false;
      activePointers.forEach(pointer => {
        if (pointer.x < mid) leftTouch = true;
        else rightTouch = true;
      });
    }

    stageEl.addEventListener('pointerdown', (e) => {
      if (!started) return;

      e.preventDefault();
      stageEl.setPointerCapture(e.pointerId);

      wasHeld = false;
      activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
      updateTouchZones();
      showFlash(e.clientX, e.clientY);

      // Check for two-finger scan
      if (leftTouch && rightTouch) {
        clearTimeout(touchTimeout);
        touchTimeout = setTimeout(() => {
          wasHeld = true;
          performScan();
        }, 300);
      }
    }, { passive: false });

    stageEl.addEventListener('pointerup', (e) => {
      if (!activePointers.has(e.pointerId)) return;

      try { stageEl.releasePointerCapture(e.pointerId); } catch { }

      const rect = stageEl.getBoundingClientRect();
      const mid = rect.left + rect.width / 2;
      const startX = activePointers.get(e.pointerId).x;

      activePointers.delete(e.pointerId);
      clearTimeout(touchTimeout);
      updateTouchZones();

      // Only perform action if not held (scan)
      if (activePointers.size === 0 && !wasHeld) {
        // Determine action based on which side was tapped
        if (startX < mid) {
          // Left side = Move
          moveForward();
        } else {
          // Right side = Turn
          turnRight();
        }
      }
    });

    stageEl.addEventListener('pointercancel', (e) => {
      try { stageEl.releasePointerCapture(e.pointerId); } catch { }
      activePointers.delete(e.pointerId);
      clearTimeout(touchTimeout);
      updateTouchZones();
    });

    // Keyboard controls
    document.addEventListener('keydown', (e) => {
      if (e.key === 'w' || e.key === 'ArrowUp') moveForward();
      else if (e.key === 'd' || e.key === 'ArrowRight') turnRight();
    });

    // Start game with fullscreen
    function start() {
      document.getElementById('overlay').classList.add('hidden');
      started = true;

      // Request fullscreen
      const elem = document.documentElement;
      if (elem.requestFullscreen) {
        elem.requestFullscreen().catch(err => console.log('Fullscreen failed:', err));
      } else if (elem.webkitRequestFullscreen) {
        elem.webkitRequestFullscreen();
      } else if (elem.msRequestFullscreen) {
        elem.msRequestFullscreen();
      }

      loadMap();
    }

    document.getElementById('overlay').addEventListener('pointerdown', start);

    // Initialize
    loadMap();
  </script>
</body>

</html>